/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var roamsh;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/commands.js":
/*!*************************!*\
  !*** ./src/commands.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let { Block, Page, Location } = __webpack_require__(/*! ./graph */ \"./src/graph.js\");\nlet graph = __webpack_require__(/*! ./graph */ \"./src/graph.js\");\nlet configs = __webpack_require__(/*! ./configs */ \"./src/configs.js\");\n\n\nfunction argToLocation(arg) {\n    // Get node from arg\n    let node;\n    if(arg instanceof Location) {\n        return arg \n    } else if(arg instanceof Page) {\n        throw `Can't get Location from Page`\n    } else if(arg instanceof Block) {\n        node = arg\n    } else {\n        node = graph.getByPath(arg.toString())\n    }\n    // Get location from node\n    if (node instanceof Block) {\n        return new Location(node.getParent().uid, node.getOrder())\n    } else if (node instanceof Location) {\n        return node\n    } else if (node instanceof Page) {\n        throw `Argument must be a Page or a Path to a Page. `\n              `The given path \"${arg}\" lead to a node of type ${typeof(arg)}.`\n    } else {\n        throw `Can't get location from type ${typeof(node)}`\n    }\n}\n\nfunction argToBlock(arg) {\n    let node;\n    if(arg instanceof Block) {\n        return arg\n    } else if(arg instanceof Location) {\n        return new Block(arg)\n    } else if(typeof(arg) === 'string') {\n        node = graph.getByPath(arg)\n        if(node instanceof Block) {\n            return node\n        } else if(node instanceof Location) {\n            throw new Error(`Argument must be a Block or a path to a block. The given path \"${arg}\" doesn't lead to an existing block`)\n        }\n        throw new Error(`Argument must be a Block or a path to a block. The given path \"${arg}\" lead to a node of type ${typeof(node)}.`)\n    } else {\n        throw new Error(`Argument must be a Block or a path to a block. The given arg \"${arg}\" has type ${typeof(arg)}.`)\n    }\n}\n\n// Commands\n\nasync function createBlock(string=\"\", dst=\"/\") {\n    let dstLoc = argToLocation(dst)\n    await Block.create(string.toString(), dstLoc)\n}\n\nasync function deleteBlock(src=\"^\") {\n    let block = argToBlock(src)\n    await block.delete()\n}\n\nasync function moveBlock(src=\"^\", dst=\"/\") {\n    let srcBlock = argToBlock(src)\n    let dstLoc = argToLocation(dst)\n    await srcBlock.move(dstLoc)\n}\n\nasync function copyBlock(src=\"^\", dst=\"/\", opts = {recursive: true}) {\n    let srcBlock = argToBlock(src)\n    let dstLoc = argToLocation(dst)\n    await srcBlock.copy(dstLoc, opts)\n}\n\nasync function updateBlock(string, dst=\"^\") {\n    if(!string) {\n        throw new Error(\"Missing string argument\")\n    }\n    let dstBlock = argToBlock(dst)\n    await dstBlock.update(string)\n}\n\nasync function refBlock(src=\"^\", dst=\"/\") {\n    let srcBlock = argToBlock(src)\n    let dstLoc = argToLocation(dst)\n    await Block.create(srcBlock.toRef(), dstLoc)\n}\n\nasync function toggleBlock(src='^') {\n    let block = argToBlock(src)\n    await block.toggleExpand()\n}\n\nasync function zoom(src='^') {\n    let blockOrPage = graph.getByPath(src) \n    await blockOrPage.open()\n}\n\nasync function echo(string) {\n    return string\n}\n\nasync function cat(src='^') {\n    let block = argToBlock(src)\n    return block.getString()\n    //let dstLoc = argToLocation(dst)\n    //let newBlock = await Block.create(block.getString(), dstLoc)\n    //return newBlock.toRef()\n}\n\nasync function listChildren(src='^', dst='/', opts = {recursive: true}) {\n    let srcBlock = argToBlock(src)\n    let dstLoc = argToLocation(dst)\n    await srcBlock.copyChildren(dstLoc, opts)\n}\n\nasync function linkChildren(src='^', dst='/', opts = {recursive: true}) {\n    opts.reference = true;\n    return await listChildren(src, dst, opts)\n}\n\nasync function run(src=\"^\") {\n    let block = argToBlock(src)\n    let string = block.getString().trim() \n    if(!(string.startsWith('`'.repeat(3)) && string.endsWith('`'.repeat(3)))) {\n        throw new Error(`Block(uid=${block.uid}) at \"${src}\" isn't a code block`)\n    }\n    string = string\n        .replace(/^```/, \"\")\n        .replace(/```$/, \"\")\n        .trim()\n    if(!string.startsWith('javascript')) {\n        throw new Error('Only javascript code blocks are supported')\n    }\n    let code = string.replace(/^javascript/, '').trim()\n    return await (async () => eval(code))();\n}\n\nasync function js(code = \"\") {\n    return await (async () => eval(code))();\n}\n\n// Run all code blocks under user paths\nfunction loadUserCommands(recursive=true) {\n    function isCodeBlock(node) {\n        string = node.getString()\n        return string.startsWith('`'.repeat(3) + 'javascript') &&\n               string.endsWith('`'.repeat(3))\n    }\n\n    function runCommandsBelow(node, recursive=true) {\n        for(let child of node.getChildren()) {\n            if(isCodeBlock(child)) {\n              run(child.toRef())\n            }\n            if(recursive) {\n              runCommandsBelow(child)\n            }\n        }\n    }\n\n    for(let path of configs.ROAMSH_PATHS) {\n        let node = graph.getByPath(path)\n        if(node instanceof Location) continue\n        runCommandsBelow(node, recursive)\n    }\n}\n\n\nmodule.exports = { createBlock, deleteBlock, moveBlock, copyBlock, refBlock, toggleBlock, zoom, echo, cat, listChildren, linkChildren, run, loadUserCommands, argToLocation, argToBlock, js, updateBlock }\n\n//# sourceURL=webpack://roamsh/./src/commands.js?");

/***/ }),

/***/ "./src/configs.js":
/*!************************!*\
  !*** ./src/configs.js ***!
  \************************/
/***/ ((module) => {

eval("// Defaults\nconfigs = {\n    ROAMSH_TERM_LABEL: \"Roam Shell: Toggle Prompt\",\n    ROAMSH_TERM_ATTR: \"roamshTermListener\",\n    ROAMSH_CSS_ID: \"roam-term\",\n    ROAMSH_CSS: `\n    .roamsh-prompt .rm-block-text\n    {\n        background-color: rgb(235, 232, 232);\n        border-radius: 0 5px 5px 0;\n    }\n\n    .roamsh-prompt .prompt-prefix-area {\n        background-color: rgb(235, 232, 232);\n        display: flex;\n        margin-top: -1px;\n        flex: 0 0 auto;\n        padding-top: 4px;\n        padding-left: 4px;\n        padding-right: 4px;\n        border-radius: 5px 0 0 5px;\n\n    }\n    `,\n    ROAMSH_INTERPRETER: \"rrsh\",\n    ROAMSH_CLEAR: true,\n    ROAMSH_PATHS: ['[[roamsh/commands]]']\n}\nconfigs.ROAMSH_PREFIX = `(${configs.ROAMSH_INTERPRETER}) ~ %` \n\n// Replace defaults with any user defined values\nif (typeof(window) !== \"undefined\") {\n    for(let [key, value] of Object.entries(configs)) {\n        configs[key] = window[key] || value\n    }\n}\n\nmodule.exports = configs\n\n//# sourceURL=webpack://roamsh/./src/configs.js?");

/***/ }),

/***/ "./src/date.js":
/*!*********************!*\
  !*** ./src/date.js ***!
  \*********************/
/***/ ((module) => {

eval("\n\nfunction getDateSuffix(d) {\n    lastDigit = d % 10\n    if (d >= 11 && d <= 13) {\n        return \"th\"\n    } else if (lastDigit === 1) {\n        return \"st\"\n    } else if (lastDigit === 2) {\n        return \"nd\"\n    } else if (lastDigit === 3) {\n        return \"rd\"\n    } else {\n        return \"th\"\n    }\n}\n\n\nfunction toRoamString(d = new Date()) {\n    const monthNames = [\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \n        \"August\", \"September\", \"October\", \"November\", \"December\"\n    ];\n    month = monthNames[d.getMonth()]\n    day = d.getDate()\n    suffix = getDateSuffix(day)\n    year = d.getFullYear()\n    return `${month} ${day}${suffix}, ${year}`\n}\n\n\nmodule.exports = { toRoamString }\n\n//# sourceURL=webpack://roamsh/./src/date.js?");

/***/ }),

/***/ "./src/graph.js":
/*!**********************!*\
  !*** ./src/graph.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var { Path, pathToLocation } = __webpack_require__(/*! ./path */ \"./src/path.js\") \nvar { sortParents, Location, NotFoundError } = __webpack_require__(/*! ./util */ \"./src/util.js\") \nlet { isBlockRef, isPageRef, isBlockUid, ParserError } = __webpack_require__(/*! ./str */ \"./src/str.js\")\nvar { toRoamString } = __webpack_require__(/*! ./date */ \"./src/date.js\") \n\n\nfunction Block(idx) {\n    if (idx instanceof Block) {\n        this.uid = idx.uid\n    } else if (idx instanceof Location) {\n        parent = new Block(location.parentUid)\n        return parent.getChildren()[location.order]\n    // Assume it's an internal id\n    } else if (typeof(idx) === \"number\") {\n        this.uid = window.roamAlphaAPI.q(`[\n            :find ?uid .\n            :where\n                [${idx} :block/uid ?uid]\n        ]`)\n    } else if (typeof(idx) === \"string\") {\n        // Assume it's a block reference or uid\n        if (isBlockRef(idx)) {\n            this.uid = idx.slice(2, -2)\n        } else if (isBlockUid(idx)) {\n            this.uid = idx\n        // Assume it's a path to a block\n        } else {\n            let uid;\n            try {\n                let path = new Path(idx)\n                uid = path.evaluate()\n            } catch(e) {\n                // If it's a ParserError, that just means it wasn't a valid path\n                // which could very well be the case. If it's a NotFoundError, we'll\n                // also skip it and throw the generic block-not-found error later\n                if(!(e instanceof ParserError || e instanceof NotFoundError)) {\n                    throw e\n                }\n            }\n            // res will be a Location or uid string\n            if(typeof(uid) === 'string') {\n                this.uid\n            }\n        }\n    }\n    if (!this.uid) throw new NotFoundError(`${idx} isn't a valid id, uid, block, or path`)\n    this.id = window.roamAlphaAPI.q(`[\n        :find ?e .\n        :where\n            [?e :block/uid \"${this.uid}\"]\n    ]`)\n}\nBlock.getFocused = function() {\n    let res = roamAlphaAPI.ui.getFocusedBlock()\n    if (res) {\n        return new Block(res[\"block-uid\"])\n    } else {\n        let el = document.activeElement\n        while(el && !(el.classList.contains(\"roam-block\"))) {\n            el = el.parentElement \n        }\n        let id = el.id || \"\"\n        let match = id.match(/block-input-.*\\d\\d-\\d\\d-\\d\\d\\d\\d-(.*)/) || []\n        if(match[1]) {\n            return new Block(match[1])\n        }    \n    }\n    return null\n}\nBlock.getOpen = async function() {\n    let obj = await getOpen()\n    if (obj instanceof Block) {\n        return obj\n    }\n    return null\n}\nBlock.create = async function (string = \"\", location=null) {\n    if (!location) {\n        let block = Block.getFocusedBlock()\n        location = new Location(block.uid, 0)\n    }\n    // Create block\n    let uid = window.roamAlphaAPI.util.generateUID();\n    await window.roamAlphaAPI.createBlock(\n        {\n            \"location\": { \"parent-uid\": location.parentUid, \"order\": location.order },\n            \"block\": { \"string\": string, \"uid\": uid }\n        }\n    );\n    return new Block(uid)\n}\nBlock.prototype = {\n    ...Block.prototype,\n    // Edit \n    update: async function (string) {\n        res = await window.roamAlphaAPI\n            .updateBlock(\n                { \"block\": { \"uid\": this.uid, \"string\": string } })\n        this.string = string\n        return res\n    },\n    delete: async function () {\n        await window.roamAlphaAPI.deleteBlock(\n            {\n                \"block\": { \"uid\": this.uid }\n            }\n         );\n    },\n    addChild: async function (child, idx = 0) {\n        if (child instanceof Block) {\n            await window.roamAlphaAPI.moveBlock(\n                {\n                    \"location\": { \"parent-uid\": this.uid, \"order\": idx },\n                    \"block\": { \"uid\": child.uid }\n                }\n            );\n            return new Block(child.uid)\n        } else {\n            return Block.create(child.toString(), new Location(this.uid, idx))\n        }\n    },\n    appendChild: async function (blockOrString) {\n        let idx = (await this.getChildren() || []).length\n        return this.addChild(blockOrString, idx)\n    },\n    addSibling: async function(sibling = '', idx=0) {\n        if (sibling instanceof Block) {\n            await window.roamAlphaAPI.moveBlock(\n                {\n                    \"location\": { \"parent-uid\": this.getParent().uid, \"order\": this.getOrder() + idx },\n                    \"block\": { \"uid\": sibling.uid }\n                }\n            );\n            return new Block(sibling.uid)\n        }\n        return Block.create(sibling.toString(), new Location(this.getParent().uid, this.getOrder() + idx))\n    },\n    addSiblingAbove: async function(sibling='', idx=0) {\n        if(idx < 0) {\n            throw `Indexer must be positive: ${idx}`\n        }\n        return await this.addSibling(sibling, -idx)\n    },\n    addSiblingBelow: async function(sibling='', idx=0) {\n        if(idx < 0) {\n            throw `Indexer must be positive: ${idx}`\n        }\n        return await this.addSibling(sibling, idx+1)\n    },\n    move: async function (idx) {\n        let location = getLocation(idx)\n        window.roamAlphaAPI.moveBlock(\n            {\n                \"location\": { \"parent-uid\": location.parentUid, \"order\": location.order },\n                \"block\": { \"uid\": this.uid }\n            }\n         );\n         return this\n    },\n    copy: async function(idx, opts = {recursive: true, reference: false}) {\n        let location = getLocation(idx)\n        let string = opts.reference ? this.toRef() : this.getString() \n        let block = await Block.create(string, location)\n        if(!opts.recursive) return\n        for(let [i, child] of this.getChildren().entries()) {\n            await child.copy(new Location(block.uid, i), opts)\n        }\n        return block\n    },\n    copyChildren: async function(idx, opts = {recursive: true, reference: false}) {\n        let location = getLocation(idx)\n        let newChildren = [];\n        for (let child of this.getChildren()) {\n            newChildren.push(await child.copy(location, opts))\n            location.order += 1\n        }\n        return newChildren\n    },\n    // UI\n    toggleExpand: async function () {\n        await window.roamAlphaAPI.updateBlock(\n            {\"block\": { \"uid\": this.uid, \"open\": !this.getOpen() }}\n         );\n    },\n    open: async function () {\n        await window.roamAlphaAPI.ui.mainWindow.openBlock(\n            {block: {uid: this.uid}}\n        )\n    },\n    focus: function() {\n        return window.roamAlphaAPI.ui.setBlockFocusAndSelection(\n            {location: {\n                \"block-uid\": this.uid, \n                \"window-id\": \"main-window\"\n            }\n        });\n    },\n    // Datomic properties\n    pull: function() {\n        return window.roamAlphaAPI.pull(\"[*]\", this.id)\n    },\n    getUid: function() {\n        return this.uid\n    },\n    getId: function() {\n        return this.id\n    },\n    getChildren: function () {\n        let ids = this.getPropertyList(\"children\")\n        return ids\n            .map((id) => new Block(id))\n            .sort((x,y) => x.getOrder() - y.getOrder())\n    },\n    getString: function() {\n        return this.getProperty(\"string\")\n    },\n    getOrder: function() {\n        return this.getProperty(\"order\")\n    }, \n    getRefs: function() {\n        let ids = this.getPropertyList(\"refs\")\n        return ids.map(id => getById(id))\n    },\n    getParents: function (sorted=true) {\n        let parents = window.roamAlphaAPI.q(`[\n            :find [(pull ?p [*]) ...]\n            :where\n                [?e :block/uid \"${this.uid}\"]\n                [?e :block/parents ?p]\n        ]`)\n        if (sorted) parents = sortParents(parents)\n        return parents.map(obj => getById(obj.id))\n    },\n    getPage: function() {\n        let id = this.getProperty(\"page\")\n        return new Page(id)\n\n    },\n    getHeading: function() {\n        return this.getProperty(\"heading\")\n    },\n    getOpen: function() {\n        return this.getProperty(\"open\")\n    },\n    getTextAlign: function() {\n        return this.getProperty(\"text-align\")\n    },\n    getProps: function() {\n        return this.getProperty(\"props\")\n    },\n    getCreateEmail: function() {\n        return this.getProperty(\"email\", \"create\")\n    },\n    getCreateTime: function() {\n        return this.getProperty(\"time\", \"create\")\n    },\n    getEditEmail: function() {\n        return this.getProperty(\"email\", \"edit\")\n    },\n    getEditTime: function() {\n        return this.getProperty(\"time\", \"edit\")\n    },\n    getLookup: function() {\n        let ids = this.getPropertyList(\"lookup\", \"attrs\")\n        return ids.map(id => getById(id))\n    },\n    // Derived properties\n    getBackRefs: function() {\n        return getBackRefs(this.uid)\n    },\n    getCreateDate: function() {\n        return new Date(this.getCreateTime())\n    },\n    getEditDate: function() {\n        return new Date(this.getEditTime())\n    },\n    getLocation: function () {\n        let parent = this.getParent()\n        return new Location(parent.uid, this.getOrder())\n    },\n    getFirstChildLocation: function() {\n        return new Location(this.uid, 0)\n    },\n    getNextChildLocation: function() {\n        let children = this.getChildren()\n        return new Location(this.uid, children.length)\n    },\n    toRef: function () {\n        return `((${this.uid}))`\n    },\n    toLocation: function() {\n        return new Location(this.getParent().uid, this.getOrder())\n    },\n    getPageRefs: function(inherit=true) {\n        let ids = window.roamAlphaAPI.q(`[\n            :find [ ?r ... ]\n            :where\n                [?e :block/uid \"${this.uid}\"]\n                [?e :block/refs ?r]\n                [?r :node/title]\n        ]`)\n        let refs = ids.map(id => getById(id))\n        if(inherit) {\n            let parents = this.getParents()\n            refsInParents = parents.map(p => p.getPageRefs(false)).flat()\n            refs = refs.concat(refsInParents) \n            refs.push(parents[0])\n        }\n        return [...new Set(refs)]\n    },\n    getBlockRefs: function() {\n        let ids = window.roamAlphaAPI.q(`[\n            :find [ ?r ... ]\n            :where\n                [?e :block/uid \"${this.uid}\"]\n                [?e :block/refs ?r]\n                [?r :block/string]\n        ]`)\n        return ids.map(id => getById(id))\n    },\n    getParent: function () {\n        return this.getParents().slice(-1)[0]\n    },\n    getSiblingAbove: function () {\n        return this.getSiblingAdjacent(-1)\n    },\n    getSiblingBelow: function () {\n        return this.getSiblingAdjacent(1)\n    },\n    getSiblingAdjacent: function(offset=1) {\n        res = this.getSiblings().filter(({ order }) => order == this.order + offset)\n        return res[0]\n    },\n    getSiblings: function () {\n        let parent = this.getParent()\n        return parent.getChildren()\n    },\n    getRelative: function (offset) {\n        if (offset.direction === siblingDir) {\n            return this.getSiblingAdjacent(offset.magnitude)\n        } else if (offset.direction == descendantDir ) {\n            if (offset.magnitude >= 0) {\n                return this.getChildren()[offset.magnitude] \n            } else {\n                return this.getParents()[-offset.magnitude]\n            }\n        }\n    },\n    // Helpers\n    getProperty: function(name, namespace=\"block\") {\n        return window.roamAlphaAPI.q(`[\n            :find ?v .\n            :where\n                [${this.id} :${namespace}/${name} ?v]\n        ]`)\n    },\n    getPropertyList: function(name, namespace=\"block\") {\n        return window.roamAlphaAPI.q(`[\n            :find [ ?v ... ]\n            :where\n                [${this.id} :${namespace}/${name} ?v]\n        ]`)\n    },\n    getTextAreaElement: function () {\n        return this.getElement().querySelector(\"textarea\")\n    },\n    getElement: function () {\n        let blockContentElement = document.querySelector(`[id$=\"${this.uid}\"]:not(.rm-inline-reference [id$=\"${this.uid}\"])`)\n        if (!blockContentElement) {\n            return null\n        }\n        let blockContainerElement = blockContentElement.parentElement\n        while (!blockContainerElement.classList.contains(\"roam-block-container\")) {\n            blockContainerElement = blockContainerElement.parentElement\n        }\n        return blockContainerElement\n    },\n    isFocused: function() {\n        return this.getTextAreaElement() !== null\n    },\n    exists: function() {\n        let res = window.roamAlphaAPI.q(`[\n            :find ?e .\n            :where\n                [?e :block/uid \"${this.uid}\"]\n        ]`)\n        return res !== null\n    },\n    toEmbed: function() {\n        return `{{[[embed]]: ${this.toRef()}}}` \n    }\n}\n\nfunction Page(idx) {\n    if (idx instanceof Page) {\n        // Handle idx as page object\n        this.uid = idx.uid\n        this.id = idx.id\n        return\n    } else if (typeof(idx) === \"number\") {\n        // Handle idx as internal id\n        let obj = window.roamAlphaAPI.pull(\"[*]\", idx)\n        if (obj[\":node/title\"] === undefined) {\n            throw new NotFoundError(\"id ${idx} exists but isn't a Page object\")\n        }\n        this.uid = obj[\":block/uid\"]\n        this.id = obj[\":db/id\"]\n        return\n    } else if (typeof(idx) === \"string\") {\n        let res, id, uid;\n        // Handle idx as a page title\n        let title = isPageRef(idx) ? idx.slice(2,-2) : idx\n        res = window.roamAlphaAPI.q(`[\n            :find [ ?e ?uid ]\n            :where\n                [?e :node/title \"${title}\"]\n                [?e :block/uid ?uid]\n        ]`)\n        if (res) {\n            [id, uid] = res\n            this.id = id\n            this.uid = uid\n            return\n        }\n        // Handle idx as uid\n        id = window.roamAlphaAPI.q(`[\n            :find ?e .\n            :where\n                [?e :node/title]\n                [?e :block/uid \"${idx}\"]\n        ]`)\n        if (id) {\n            this.id = id\n            this.uid = idx\n            return\n        }\n    }\n    throw new NotFoundError(`\"${idx}\" isn't a valid page id, uid, or title. If you're trying to create a new page, use \\`Page.create(\"your title\")\\``)\n}\nPage.create = async function (title) {\n    if (!Page.exists(title)) {\n        let uid = window.roamAlphaAPI.util.generateUID()\n        await window.roamAlphaAPI.createPage({page: {title: title, uid: uid}})\n    }\n    return new Page(title)\n}\nPage.getOpen = async function() {\n    let obj = await getOpen()\n    if (obj instanceof Block) {\n        return obj.getPage()\n    }\n    return obj\n}\nPage.exists = function(title) {\n    let res = window.roamAlphaAPI.q(`[\n        :find ?e .\n        :where\n            [?e :node/title \"${title}\"]\n    ]`)\n    return res !== null\n},\nPage.prototype = {\n    ...Page.prototype,\n    // Edit \n    update: async function (title) {\n        return await window.roamAlphaAPI\n            .updatePage(\n                {\"page\": { \"title\": title, \"uid\": this.uid }})\n    },\n    delete: async function () {\n        return await window.roamAlphaAPI.deletePage({\"page\": {\"uid\": this.uid }});\n    },\n    addChild: async function (blockOrString, idx = 0) {\n        let loc = new Location(this.uid, idx)\n        if (blockOrString instanceof Block) {\n            let block = blockOrString\n            await block.move(loc)\n            return block\n        } else {\n            let string = blockOrString\n            return Block.create(string.toString(), loc)\n        }\n    },\n    appendChild: async function (blockOrString) {\n        let idx = (await this.getChildren() || []).length\n        return this.addChild(blockOrString, idx)\n    },\n    // UI\n    open: async function () {\n        await window.roamAlphaAPI.ui.mainWindow.openPage(\n            {page: {uid: this.uid}}\n        )\n    },\n    // Datomic properties\n    pull: function() {\n        return window.roamAlphaAPI.pull(\"[*]\", this.id)\n    },\n    getChildren: function () {\n        let ids = this.getPropertyList(\"children\")\n        return ids\n            .map((id) => new Block(id))\n            .sort((x,y) => x.getOrder() - y.getOrder())\n    },\n    getTitle: function() {\n        return this.getProperty(\"title\", \"node\")\n    },\n    getRefs: function() {\n        let ids = this.getPropertyList(\"refs\")\n        return ids.map(id => getById(id))\n    },\n    getSideBar: function() {\n        return this.getProperty(\"sidebar\", \"page\")\n    },\n    getCreateEmail: function() {\n        return this.getProperty(\"email\", \"create\")\n    },\n    getCreateTime: function() {\n        return this.getProperty(\"time\", \"create\")\n    },\n    getEditEmail: function() {\n        return this.getProperty(\"email\", \"edit\")\n    },\n    getEditTime: function() {\n        return this.getProperty(\"time\", \"edit\")\n    },\n    getLookup: function() {\n        let ids = this.getPropertyList(\"lookup\", \"attrs\")\n        return ids.map(id => getById(id))\n    },\n    // Derived properties\n    getBackRefs: function() {\n        return getBackRefs(this.uid)\n    },\n    getCreateDate: function() {\n        return new Date(this.getCreateTime())\n    },\n    getEditDate: function() {\n        return new Date(this.getEditTime())\n    },\n    getFirstChildLocation: function() {\n        return new Location(this.uid, 0)\n    },\n    getNextChildLocation: function() {\n        let children = this.getChildren()\n        return new Location(this.uid, children.length)\n    },\n    toRef: function () {\n        return `[[${this.getTitle()}]]`\n    },\n    getPageRefs: function() {\n        let refs = this.getRefs().filter(ref => ref instanceof Page)\n        return refs\n    },\n    // Helpers\n    getProperty: function(name, namespace=\"block\") {\n        return window.roamAlphaAPI.q(`[\n            :find ?v .\n            :where\n                [${this.id} :${namespace}/${name} ?v]\n        ]`)\n    },\n    getPropertyList: function(name, namespace=\"block\") {\n        return window.roamAlphaAPI.q(`[\n            :find [ ?v ... ]\n            :where\n                [${this.id} :${namespace}/${name} ?v]\n        ]`)\n    }\n}\n\nasync function getOpen() {\n    let uid = await window.roamAlphaAPI.ui.mainWindow.getOpenPageOrBlockUid()\n    return getByUid(uid)\n}\n\nfunction getById(id) {\n    let obj = window.roamAlphaAPI.pull(\"[*]\", id)\n    if (obj[\":node/title\"] === undefined) {\n        return new Block(id)\n    } else {\n        return new Page(id)\n    }\n}\n\nfunction getByUid(uid) {\n    let obj = window.roamAlphaAPI.q(`[\n        :find (pull ?e [*]) .\n        :where\n            [?e :block/uid \"${uid}\"]\n    ]`)\n    if (obj[\"title\"] === undefined) {\n        return new Block(obj[\"uid\"])\n    } else {\n        return new Page(obj[\"uid\"])\n    }\n}\n\nfunction getBackRefs(uid) {\n    let ids = window.roamAlphaAPI.q(`[\n        :find [ ?e ... ]\n        :where\n            [?e :block/refs ?refs]\n            [?refs :block/uid \"${uid}\"]\n    ]`)\n    return ids.map(id => getById(id))\n}\n\nfunction getByPath(pathString) {\n    try {\n        let path = new Path(pathString)\n        let res = path.evaluate()\n        if(res instanceof Location) {\n            return res\n        } else {\n            return getByUid(res)\n        }\n    } catch (e) {\n        if(e instanceof NotFoundError) {\n            return null\n        }\n        throw e\n    }\n}\n\nfunction getPage(idx) {\n    try {\n        return new Page(idx)\n    } catch (e) {\n        if(e instanceof NotFoundError) {\n            return null\n        }\n        throw e\n    }\n}\n\nfunction getBlock(idx) {\n    try {\n        return new Block(idx)\n    } catch (e) {\n        if(e instanceof NotFoundError) {\n            return null\n        }\n        throw e\n    }\n}\n\nfunction getLocation(idx) {\n    if(idx instanceof Location) {\n        return idx\n    } else if(idx instanceof Block) {\n        return idx.toLocation()\n    } else if(idx instanceof Page) {\n        throw new Error(\"Pages don't have locations\")\n    } else if(typeof(idx) === 'string') {\n        let path = new Path(idx)\n        let res = path.evaluate()\n        if(res instanceof Location) {\n            return res\n        }\n        let block = new Block(idx)\n        return block.toLocation()\n    } else {\n        throw new TypeError(`Invalid type: ${typeof(idx)}`) \n    }\n}\n\nfunction getDailyNote(date = new Date()) {\n    let title = toRoamString(date)\n    return getPage(title)\n}\n\nfunction get(idx) {\n    let res;\n    if(idx instanceof Date) {\n        return getDailyNote(idx)\n    } else if (res = getBlock(idx)) {\n        return res\n    } else if (res = getPage(idx)) {\n        return res\n    } else {\n        try {\n            return getByPath(idx)\n        } catch (e) {\n            if(e instanceof ParserError) {\n                return null\n            }\n            throw e\n        }\n    }\n}\n\nasync function asyncDailyNote(date = new Date()) {\n    let title = toRoamString(date)\n    if (Page.exists(title)) {\n        return new Promise(res => res(new Page(title)))\n    } else {\n        return Page.create(title) // returns a promise\n    }\n}\n\nasync function getOpenPage() {\n    let obj = await getOpen()\n    if (obj instanceof Page) {\n        return obj\n    } else {\n        return obj.getPage()\n    }\n}\n\n\nmodule.exports = { Block, Page, Location, getOpen, getOpenPage, getPage, getBlock, getByPath, get, getDailyNote, asyncDailyNote }\n\n//# sourceURL=webpack://roamsh/./src/graph.js?");

/***/ }),

/***/ "./src/path.js":
/*!*********************!*\
  !*** ./src/path.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let { PageRefParser, BlockRefParser, Parser, ParserError, Token } = __webpack_require__(/*! ./str */ \"./src/str.js\") \nlet { Location, NotFoundError } = __webpack_require__(/*! ./util */ \"./src/util.js\")\nlet util = __webpack_require__(/*! ./util */ \"./src/util.js\")\n\nROOT_CHAR = \"~\"\nPARENT_CHAR = \".\"\nFOCUSED_CHAR = \"_\"\n\nlet TOKEN_TYPES_LIST = [\n    \"PATH\", \"START_ROOT\", \"START_PARENT\", \"START_PAGE\", \"START_BLOCK\", \"START_FOCUSED\",\n    \"STEP_TO_SIBLING_ABOVE\", \"STEP_TO_SIBLING_BELOW\", \"STEP_TO_CHILD\", \"STEP_TO_PARENT\"]\nTOKEN_TYPES_LIST.forEach(type => Token.TYPES[type] = type)\n\nfunction Path(string) {\n    this.string = string;\n    let parser = new PathParser(string)\n    let pathToken = parser.parse()\n    let [start, ...steps] = pathToken.value\n    this.start = start;\n    this.steps = steps;\n}\nPath.prototype = {\n    ...Path.prototype,\n    split: function() {\n        return [ this.start.lexeme ].concat(path) + this.offset.map(o => o.lexeme).join(\"\")\n    },\n    evaluate: function() {\n        interpreter = new PathInterpreter(this)\n        return interpreter.evaluate()\n    }\n}\n\nfunction PathParser(string, current = 0) {\n    Parser.call(this, string, current)\n    this.tokenType = Token.TYPES.PATH\n}\nPathParser.prototype = Object.create(Parser.prototype)\nPathParser.prototype.constructor = PathParser\nPathParser.prototype.parse = function() {\n    if(this.current !== 0) {\n        throw this.error(`Can only call parse from start of string, not: current = ${this.current}`)\n    }\n    let tokenStart = this.current;\n    let tokens = []\n\n    tokens.push(this.tokenizeStart())\n    let stepStart = this.current;\n    while (!this.isAtEnd()) {\n        let step = this.tokenizeStep()\n        if(!step) {\n            throw this.error(\"Invalid step character\", stepStart, this.current)\n        }\n        tokens.push(step)\n    }\n    return new Token(this.tokenType, this.string, tokens, tokenStart)\n}\nPathParser.prototype.tokenizeThis = function() {\n    let tokenStart = this.current;\n\n    // tokenize start and step tokens\n    let tokens = []\n    tokens.push(this.tokenizeStart())\n    while (!this.isAtEnd()) {\n        let step = this.tokenizeStep()\n        if (!step) break\n        tokens.push(step)\n    }\n    \n    // Did we find an empty path?\n    if(tokens[0].lexeme === \"\" && tokens.length <= 1) {\n        // That's valid syntax if we're tokenizing a single path string \n        // but not if we're tokenizing a substring within a larger string\n        if(this.string !== \"\") {\n            this.current = tokenStart;\n            return null\n        }\n    }\n    let lexeme = this.string.slice(tokenStart, this.current);\n    return new Token(this.tokenType, lexeme, tokens, tokenStart)\n}\nPathParser.prototype.tokenizeStart = function() {\n    let tokenStart = this.current; \n    let string, token;\n    if(string = this.advance(ROOT_CHAR)) {\n        return new Token(Token.TYPES.START_ROOT, string, string, tokenStart) \n    } else if(string = this.advance(FOCUSED_CHAR)) {\n        return new Token(Token.TYPES.START_FOCUSED, string, string, tokenStart) \n    } else if(token = this.tokenize(PageRefParser)) {\n        return new Token(Token.TYPES.START_PAGE, token.lexeme, token, tokenStart) \n    } else if(token = this.tokenize(BlockRefParser)) {\n        return new Token(Token.TYPES.START_BLOCK, token.lexeme, token, tokenStart) \n    } else {\n        return new Token(Token.TYPES.START_FOCUSED, \"\", \"\", tokenStart) \n    }\n}\nPathParser.prototype.tokenizeStep = function() {\n    let tokenStart = this.current;\n\n    // Get step type\n    let type;\n    if (this.advance(\"^\")) {\n        type = Token.TYPES.STEP_TO_SIBLING_ABOVE\n    } else if (this.advance(\"$\")) {\n        type = Token.TYPES.STEP_TO_SIBLING_BELOW \n    } else if (this.advance(\"/\")) {\n        type = Token.TYPES.STEP_TO_CHILD \n    } else if (this.advance(\".\")) {\n        type = Token.TYPES.STEP_TO_PARENT \n    } else {\n        return null;\n    }\n    // Get step selector string\n    let token;\n    let stepSelector = \"\";\n    while (!this.isAtEnd()) {\n        let escapedChar = this.escape()\n        if(escapedChar !== null) {\n            stepSelector += escapedChar\n        } else if(token = this.tokenize(PageRefParser)) {\n            stepSelector += token.lexeme\n        } else if(this.check(\"^\", \"$\", \"/\", \".\")) {\n            break\n        } else {\n            stepSelector += this.advance(1)\n        }\n    }\n\n    // Create step token\n    let lexeme = this.string.slice(tokenStart, this.current);\n    let value;\n    let match = stepSelector.match(/\\[([1-9]*\\d)\\]/)\n    if(!stepSelector) {\n        value = 0;\n    } else if(match) {\n        value = parseInt(match[1]);\n    } else {\n        value = stepSelector;\n    }\n    return new Token(type, lexeme, value, tokenStart)\n}\nPathParser.prototype.escape = function() {\n    if(!this.advance('\\\\')) {\n        return null;\n    }\n    if(this.isAtEnd()) {\n        return '\\\\'\n    }\n    return this.advance()\n}\n\nPathParser.prototype.error = function(message, stepIndex, errorIndex, errorLength) {\n    if (stepIndex && errorIndex) {\n        errorLength = errorLength || 1\n        lines = []\n        lines.push(message)\n        lines.push(\"\")\n        lines.push(`Start: \"${this.string.slice(0, stepIndex)}\"`)\n        lines.push(`Steps: \"${this.string.slice(stepIndex)}\"`)\n        lines.push(`        ${\" \".repeat(errorIndex - stepIndex) + \"^\".repeat(errorLength)}`)\n        message = lines.join(\"\\n\")\n    }\n    return new ParserError(message)\n}\n\nfunction PathInterpreter(path) {\n    if (!(path instanceof Path)) {\n        path = new Path(path)\n    }\n    this.path = path\n    this.current;\n}\nPathInterpreter.prototype.error = function(message, token) {\n    if (token) {\n        string = this.path.string\n        pointer = \" \".repeat(token.index) + \"^\".repeat(token.lexeme.length)\n        message += \"\\n\\n\" + string + \"\\n\" + pointer\n    }\n    throw NotFoundError(message)\n}\nPathInterpreter.prototype.evaluate = function() {\n    // Go to start\n    let current = this.start(this.path.start) \n    // Follow steps\n    for (let token of this.path.steps) {\n        current = this.step(current, token)\n    }\n    return current\n}\nPathInterpreter.prototype.start = function(token) {\n    if(token.type === Token.TYPES.START_ROOT) {\n        throw new NotFoundError(`No support for paths starting at ${path.start} yet :(`);\n    } else if(token.type === Token.TYPES.START_FOCUSED) {\n        return util.getFocused()\n    } else if(token.type === Token.TYPES.START_PAGE) {\n        return this.page(token.value)\n    } else if(token.type === Token.TYPES.START_BLOCK) {\n        return this.block(token.value)\n    }\n    this.error(\"Invalid path start\", token)\n}\nPathInterpreter.prototype.step = function(current, token) {\n    if (current instanceof Location) {\n        this.error(\"Can't apply step once path reaches a new location\", token)\n    }\n    let uid = current;\n    if(token.type === Token.TYPES.STEP_TO_CHILD) {\n        return this.stepToChild(uid, token)\n    } else if (token.type === Token.TYPES.STEP_TO_PARENT) {\n        return this.stepToParent(uid, token)\n    } else if (token.type === Token.TYPES.STEP_TO_SIBLING_ABOVE ||\n               token.type === Token.TYPES.STEP_TO_SIBLING_BELOW) {\n        return this.stepToSibling(uid, token)\n    } else {\n        throw `Invalid step type: ${token.type}`\n    }\n}\nPathInterpreter.prototype.page = function(pageToken) {\n    let title = pageToken.value.map(token => token.lexeme).join(\"\")\n    let uid = window.roamAlphaAPI.q(`[\n        :find ?uid .\n        :where\n            [?e :node/title \"${title}\"]\n            [?e :block/uid ?uid]\n    ]`)\n    return uid\n}\nPathInterpreter.prototype.block = function(blockToken) {\n    return blockToken.value[0].lexeme\n}\nPathInterpreter.prototype.stepToChild = function(uid, token) {\n    let children = util.getChildren(uid)\n    // Handle indexer\n    if(typeof(token.value) === 'number') {\n        let childNum = token.value\n        if (children.length === 0) {\n            if (childNum >= 1) {\n                this.error('Child path index must be <=0 when node has no children', token);\n            } else {\n                return new Location(uid, 0)\n            }\n        } else if (childNum < 0) {\n            return children.slice(childNum)[0]\n        } else if (childNum < children.length) {\n            return children[childNum]\n        } else {\n            return new Location(util.getParent(uid), children.length)\n        }\n    // Handle search string\n    } else {\n        let matches = children.filter(uid => util.getString(uid) === token.value)\n        if (matches.length === 0) {\n            this.error(\"No children matching search string\", token)\n        }\n        return matches[0]\n    }\n}\nPathInterpreter.prototype.stepToParent = function(uid, token) {\n    let parents = util.getParents(uid).reverse()\n    // Handle indexer\n    if(typeof(token.value) === 'number') {\n        let parentNum = token.value\n        if (parentNum < 0) {\n            return parents.slice(parentNum)[0]\n        } else {\n            return parents[parentNum]\n        }\n    // Handle search string\n    } else {\n        let matches = parents.filter(uid => util.getString(uid) === token.value)\n        if (matches.length === 0) {\n            this.error(\"No parents matching search string\", token)\n        }\n        return matches[0]\n    }\n}\nPathInterpreter.prototype.stepToSibling = function(uid, token) {\n    if (util.isPage(uid)) {\n        this.error(\"Can't select a sibling of a Page\", token)\n    }\n    let siblings = util.getSiblings(uid)\n    currentOrder = util.getOrder(uid)\n    // Handle indexer\n    if(typeof(token.value) === 'number') {\n        let order;\n        if(token.type === Token.TYPES.STEP_TO_SIBLING_ABOVE) {\n            order = currentOrder - (token.value + 1)\n        } else {\n            order = currentOrder + (token.value + 1)\n        }\n        if (order < 0) {\n            return new Location(util.getParent(uid), 0)\n        } else if (order < siblings.length) {\n            return siblings[order]\n        } else if (order >= siblings.length) {\n            return new Location(util.getParent(uid), siblings.length)\n        }    \n    // Handle search string\n    } else {\n        if(token.type === Token.TYPES.STEP_TO_SIBLING_ABOVE) {\n            siblings = siblings.slice(0, currentOrder).reverse()\n        } else {\n            siblings = siblings.slice(currentOrder + 1)\n        }\n        let matches = siblings.filter(uid => util.getString(uid) === token.value)\n        if (matches.length === 0) {\n            this.error(\"No parents matching search string\", token)\n        }\n        return matches[0]\n    }\n}\n\n\n\nfunction pathToLocation(path) {\n    if(typeof(path) === 'string') {\n        path = new Path(path)\n    }\n    if(!(path instanceof Path)) {\n        throw new Error(`Argument must be a Path or path string.`)\n    }\n    let res = path.evaluate()\n    // res will be a Location or uid string\n    if(res instanceof Location) {\n        return res\n    } else {\n        let uid = res\n        return new Location(util.getParent(uid), util.getOrder(uid))\n    }\n}\n\nmodule.exports = { Path, PathParser, pathToLocation }\n\n//# sourceURL=webpack://roamsh/./src/path.js?");

/***/ }),

/***/ "./src/roamsh.js":
/*!***********************!*\
  !*** ./src/roamsh.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let path = __webpack_require__(/*! ./path */ \"./src/path.js\") \nlet graph = __webpack_require__(/*! ./graph */ \"./src/graph.js\") \nlet commands = __webpack_require__(/*! ./commands */ \"./src/commands.js\") \nlet terminal = __webpack_require__(/*! ./terminal */ \"./src/terminal.js\") \nlet date = __webpack_require__(/*! ./date */ \"./src/date.js\") \nlet configs = __webpack_require__(/*! ./configs */ \"./src/configs.js\") \nlet util = __webpack_require__(/*! ./util */ \"./src/util.js\") \n\n// Set up terminal\nterminal.Terminal.setUp()\n\n// Create global variables for built-in commands\nmv = moveBlock = commands.moveBlock\ncp = copyBlock = commands.copyBlock\nln = refBlock = commands.refBlock\nrm = deleteBlock = commands.deleteBlock\ntouch = createBlock = commands.createBlock\nex = toggleBlock = commands.toggleBlock\nzm = zoom = commands.zoom \nls = listChildren = commands.listChildren\nlk = linkChildren = commands.linkChildren\necho = commands.echo\ncat = commands.cat\nrun = commands.run\njs = commands.js\nud = commands.updateBlock\n\n// Load user commands defined in configs.ROAMSH_PATHS\ncommands.loadUserCommands()\n\nmodule.exports = { path, graph, commands, terminal, date, configs, util, ...graph }\n\n//# sourceURL=webpack://roamsh/./src/roamsh.js?");

/***/ }),

/***/ "./src/rrsh.js":
/*!*********************!*\
  !*** ./src/rrsh.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nfunction RoamResearchShell() {\n    this.hadError = false;\n}\nRoamResearchShell.error = function(index, message) {\n    report(index, \"\", message)\n}\nRoamResearchShell.report = function(index, message) {\n    console.error(`[index ${index}] Error: ${message}`);\n    this.hadError = true;\n}\nRoamResearchShell.prototype = {\n    ...RoamResearchShell.prototype,\n    transpile: function(source) {\n        let scanner = new Scanner(source);\n        let tokens = scanner.scanTokens();\n        let parser = new Parser(tokens)\n        let expression = parser.parse()\n        let transpiler = new Transpiler()\n        return transpiler.transpile(expression)\n    },\n    run: async function(source) {\n        let [func, ...args] = this.transpile(source)\n        return await func(...args) \n    }\n}\n\n// Scanner\n\nconst tokenTypeList = [\n    \"BACKSLASH\", \"SPACE\", \"SEMI_COLON\",\n    \"QUOTE_DOUBLE\", \"QUOTE_SINGLE\", \"QUOTE_BACK\",\n    \"SQUARE_OPEN\", \"SQUARE_CLOSE\",\n    \"SINGLE_SQUARE_OPEN\", \"SINGLE_SQUARE_CLOSE\",\n    \"CHAR\", \"DOLLAR\", \"CARROT\"\n];\nTokenType = {}\ntokenTypeList.forEach(type => TokenType[type] = type)\n\n\nfunction Token(type, lexeme, literal, index) {\n    this.type = type;\n    this.lexeme = lexeme;\n    this.literal = literal;\n    this.index = index;\n}\nToken.prototype.toString = function() {\n    return `${this.type} ${this.lexeme} ${this.literal}`\n}\n\n\nfunction Scanner(source) {\n    this.source = source;\n    this.tokens = [];\n    this.start = 0;\n    this.current = 0;\n}\nScanner.prototype = {\n    ...Scanner.prototype,\n    scanTokens: function() { while (!this.isAtEnd()) {\n            this.start = this.current;\n            this.scanToken()\n        }\n        return this.tokens;\n    },\n    scanToken: function() {\n        var c = this.source[this.current]\n        if (c === '\\\\') {\n            this.addToken(TokenType.BACKSLASH)\n        }\n        else if (c === \" \") {\n            // treat each individually cause the first might be escape, becoming a character\n            this.addToken(TokenType.SPACE)\n        }\n        else if (c === \";\") {\n            this.addToken(TokenType.SEMI_COLON);\n        }\n        else if (c === '\"') {\n            this.addToken(TokenType.QUOTE_DOUBLE);\n        }\n        else if (c === \"'\") {\n            this.addToken(TokenType.QUOTE_SINGLE);\n        }\n        else if (c === \"`\") {\n            this.addToken(TokenType.QUOTE_BACK);\n        }\n        else if (c === \"[\") {\n            this.addToken(TokenType.SQUARE_OPEN, \"[\");\n        }\n        else if (c === \"]\") {\n            this.addToken(TokenType.SQUARE_CLOSE, \"]\");\n        }\n        else {\n            this.addToken(TokenType.CHAR, c);\n            // RoamScript.error(index, message)\n        }\n        this.advance()\n    },\n    addToken: function(type, literal=null) {\n        var lexeme = this.source.slice(this.start, this.current + 1)\n        var token = new Token(type, lexeme, literal, this.start)\n        this.tokens.push(token)\n    },\n    advance: function() {\n        this.current += 1\n    },\n    isAtEnd: function() {\n        return this.current >= this.source.length;\n    }\n}\n\n// Expressions\n\nExpr = {\n    Command: function(...expressions) {\n        this.expressions = expressions;\n    },\n    Concat: function(...expressions) {\n        this.expressions = expressions;\n    },\n    PageRef: function(...expressions) {\n        this.expressions = expressions;\n    },\n    Quote: function(...expressions) {\n        this.expressions = expressions;\n    },\n    Literal: function(value) {\n        this.value = value;\n    } \n}\n// Add visitor interface to each Expression\nfor (const [name, constructor] of Object.entries(Expr)) {\n    constructor.prototype.accept = function (visitor) {\n        return visitor[\"visit\"+name](this)\n    }\n}\n\n\n\n// Parser\n\nfunction Parser(tokens) {\n    this.tokens = tokens;\n    this.current = 0;\n}\nParser.prototype = {\n    ...Parser.prototype,\n    parse: function() {\n        return this.command()\n    },\n    command: function() {\n        var terms = [];\n        var term = this.term()\n        while (term) {\n            terms.push(term)\n            var term = this.term()\n        }\n\n        return new Expr.Command(...terms)\n    },\n    term: function() {\n        var expressions = []\n        while (!this.match(TokenType.SPACE) && !this.isAtEnd()) {\n            expressions.push(this.primary())\n        }\n        if (expressions.length === 0) return false\n        if (expressions.length === 1) return expressions[0]\n        return new Expr.Concat(...expressions)\n    },\n    primary: function() {\n        if (this.match(TokenType.BACKSLASH)) {\n            return new Expr.Literal(this.advance().lexeme)\n        }\n        expr = this.quote()\n        if (expr) return expr\n        expr = this.pageRef()\n        if (expr) return expr\n        return new Expr.Literal(this.advance().lexeme)\n    },\n    quote: function() {\n        let start = this.current\n        if (!(this.match(TokenType.QUOTE_DOUBLE, TokenType.QUOTE_SINGLE, TokenType.QUOTE_BACK))) {\n            return false\n        }\n        let openToken = this.previous()\n\n        var inner = []\n        while (!(this.checkMany(openToken.type) || this.isAtEnd())) {\n            let expr;\n            if (this.match(TokenType.BACKSLASH)) {\n                inner.push(new Expr.Literal(this.advance().lexeme))\n            } else if(expr = this.pageRef()) {\n                inner.push(expr)\n            } else {\n                inner.push(new Expr.Literal(this.advance().lexeme))\n            }\n        }\n\n        if (!this.match(openToken.type)) {\n            this.current = start\n            return false\n        }\n        return new Expr.Quote(...inner)\n    },\n    pageRef: function() {\n        let start = this.current\n        // Start of page ref\n        if (!(this.matchMany(TokenType.SQUARE_OPEN, TokenType.SQUARE_OPEN))) {\n            return false\n        }\n\n        // Inside page ref\n        var inner = []\n        while (!(this.checkMany(TokenType.SQUARE_CLOSE, TokenType.SQUARE_CLOSE) || this.isAtEnd())) {\n            inner.push(this.primary())\n        }\n\n        // End of page ref\n        if (!(this.matchMany(TokenType.SQUARE_CLOSE, TokenType.SQUARE_CLOSE))) {\n            this.current = start\n            return false\n        }\n        return new Expr.PageRef(...inner)\n    },\n    previous: function(i=0) {\n        if (i === 0) return this.tokens[this.current - 1] \n        return this.tokens.slice(this.current - i, this.current)\n    },\n    peek: function(i=0) {\n        return this.tokens[this.current + i]\n    },\n    advance: function(i=1) {\n        if (!this.isAtEnd()) this.current += i\n        return this.previous()\n\n    },\n    // Check the next series of token types match given types then advance\n    checkMany: function(...tokenTypes) {\n        for (let [i, tokenType] of tokenTypes.entries()) {\n            if (this.isAtEnd(i)) return false;\n            if (tokenType !== this.peek(i).type) {\n                return false\n            }\n        }\n        return true\n    },\n    // Same as checkMany but advance if true\n    matchMany: function(...tokenTypes) {\n        if (this.checkMany(...tokenTypes)) {\n            this.advance(tokenTypes.length)\n            return true\n        }\n        return false\n    },\n    // Check the next token matches _any_ of tokenTypes\n    check: function(...tokenTypes) {\n        if (this.isAtEnd()) return false;\n        for (let tokenType of tokenTypes) {\n            if (tokenType === this.peek().type) {\n                return true\n            }\n        }\n        return false\n    },\n    // Same as check but advance if true\n    match: function(...tokenTypes) {\n        if (this.check(...tokenTypes)) {\n            this.advance()\n            return true\n        }\n        return false\n    },\n    isAtEnd: function(i=0) {\n        return (this.current + i) >= this.tokens.length\n    },\n}\n\n\nfunction AstPrinter() {}\nAstPrinter.prototype = {\n    ...AstPrinter.prototype,\n    print: function(expression) {\n        return expression.accept(this);\n    },\n    visitPageRef: function(expr) {\n        return this.parenthesize(\"PageRef\", ...expr.expressions)\n    },\n    visitQuote: function(expr) {\n        return this.parenthesize(\"Quote\", ...expr.expressions)\n    },\n    visitCommand: function(expr) {\n        return this.parenthesize(\"Command\", ...expr.expressions)\n    },\n    visitConcat: function(expr) {\n        return this.parenthesize(\"Concat\", ...expr.expressions)\n    },\n    visitLiteral: function(expr) {\n        if (expr.value === null) return \"nil\";\n        return '\"' + expr.value.toString() + '\"'\n    },\n    parenthesize: function(name, ...exprs) {\n        exprsString = exprs.map(expr => expr.accept(this)).join(\" \")\n        // expr.accept(this) runs the printer on the expression\n        return `(${name} ${exprsString})` \n    }\n}\n\n\nfunction RuntimeError(message) {\n    instance = new Error(message);\n    instance.name = 'RuntimeError';\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, RuntimeError);\n      }\n    return instance;\n}\nRuntimeError.prototype = Object.create(Error.prototype)\nRuntimeError.prototype.constructor = RuntimeError\n\n\nfunction Transpiler() {}\nTranspiler.prototype = {\n    ...Transpiler.prototype,\n    transpile: function(expr) {\n        return this.evaluate(expr)\n    },\n    visitCommand: function(expr) {\n        let terms = expr.expressions.map(expr => this.evaluate(expr))\n        var func = this.getCommand(terms[0])\n        var args = terms.slice(1)\n        return [func, ...args]\n    },\n    getCommand: function(cmdString) {\n        let cmd;\n        try {\n            cmd = eval(cmdString)\n            if (!(cmd instanceof Function)) throw new ReferenceError()\n        } catch (e) {\n            if (e instanceof ReferenceError) {\n                throw new RuntimeError(`command not found: ${cmdString}`)\n            } \n            throw e\n        }\n        return cmd\n        \n    },\n    visitConcat: function(expr) {\n        return expr.expressions.map(expr => this.evaluate(expr)).join(\"\")\n    },\n    visitQuote: function(expr) {\n        return expr.expressions.map(expr => this.evaluate(expr)).join(\"\")\n    },\n    visitPageRef: function(expr) {\n        return \"[[\" + expr.expressions.map(expr => this.evaluate(expr)).join(\"\") + \"]]\"\n    },\n    visitLiteral: function(expr) {\n        return expr.value\n    },\n    evaluate: function(expr) {\n        return expr.accept(this)\n    }\n}\n\nif ( true && __webpack_require__.c[__webpack_require__.s] === module) {\n    shell = new RoamResearchShell()\n    shell.run(process.argv[2])\n}\nmodule.exports = { RoamResearchShell, Scanner, Parser }\n\n//# sourceURL=webpack://roamsh/./src/rrsh.js?");

/***/ }),

/***/ "./src/str.js":
/*!********************!*\
  !*** ./src/str.js ***!
  \********************/
/***/ ((module) => {

eval("\n\n\n\nfunction Token(type, lexeme, value=null, index=null) {\n    this.type = type\n    this.lexeme = lexeme\n    this.value = value\n    this.index = index\n}\nTOKEN_TYPE_LIST = [\"PAGE_REF\", \"BLOCK_REF\", \"LITERAL\"]\nToken.TYPES = {}\nTOKEN_TYPE_LIST.forEach(type => Token.TYPES[type] = type)\n\n\nfunction ParserError(message) {\n    instance = new Error(message);\n    instance.name = 'ParserError';\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, ParserError);\n      }\n    return instance;\n}\nParserError.prototype = Object.create(Error.prototype)\nParserError.prototype.constructor = ParserError\n\n\nfunction Parser(string, current=0) {\n    if(typeof(string) !== 'string') {\n        throw new TypeError(`The \"string\" argument must be a string. Received type ${typeof(string)} (${string})`) \n    }\n    this.string = string\n    this.current = current\n    this.tokenType;\n}\nParser.tokenType = null\nParser.prototype = {\n    ...Parser.prototype,\n    parse: function() {\n        throw new Error(\"parse not implemented\")\n    },\n    parseMany: function() {\n        let tokens = []\n        while (!this.isAtEnd()) {\n            let token;\n            if(token = this.tokenizeThis()) {\n                tokens.push(token)\n            } else {\n                this.advance(1)\n            }\n        }\n        return tokens\n    },\n    next: function() {\n        let token;\n        while(!this.isAtEnd()) {\n            if(token = this.tokenizeThis()) {\n                return token\n            }\n            this.advance(1)\n        }\n        return null;\n    },\n    tokenizeThis: function() {\n        throw new Error(\"tokenizeThis not implemented\")\n    },\n    tokenizeChar: function(n, tokens) {\n        let tokenStart = this.current;\n        let string = this.advance(n)\n        if(tokens && tokens.length) {\n            lastToken = tokens.slice(-1)[0]\n            if(lastToken.type === Token.TYPES.LITERAL) {\n                lastToken.lexeme += string\n                lastToken.value += string\n                return tokens.pop()\n            }\n        }\n        let token = new Token(Token.TYPES.LITERAL, string, string, tokenStart)\n        return token\n    },\n    tokenize: function(x) {\n        let tokenStart = this.current;\n\n        let token;\n        if(!x) {\n            if(token = this.tokenizeThis()) {\n                return token\n            } else {\n                return this.tokenize(1)\n            }\n        } else if(typeof(x) === 'string') {\n            if(this.advance(x)) {\n                return new Token(Token.TYPES.LITERAL, x, x, tokenStart)\n            }\n        } else if(typeof(x) === 'number') {\n            let string = this.advance(x)\n            return new Token(Token.TYPES.LITERAL, string, string, tokenStart)\n        } else if(x.prototype instanceof Parser) {\n            let parser = new x(this.string, this.current)\n            if(token = parser.tokenizeThis()) {\n                this.current = parser.current\n                return token\n            }\n        }\n        return null\n    },\n    advance: function(x = 1) {\n        if(typeof(x) === \"number\") {\n            let chars = this.string.slice(this.current, this.current + x)\n            this.current += chars.length\n            return chars\n        } else if(typeof(x) === \"string\") {\n            let chars = this.string.slice(this.current, this.current + x.length)\n            if(chars === x) {\n                this.current += chars.length\n                return chars\n            }\n        } else if(x.prototype instanceof Parser) {\n            let token;\n            if(token = this.tokenize(x)) {\n                return token.lexeme\n            }\n        }\n        return null\n    },\n    check: function(...strings) {\n        if(this.isAtEnd()) {\n            return false;\n        }\n        for(let string of strings) {\n            if(string === this.string.slice(this.current, this.current + string.length)) {\n                return true\n            }\n        }\n        return false\n    },\n    isAtEnd: function() {\n        return this.current >= this.string.length \n    },\n    error: function(message, start = null, length = 1) {\n        if (start !== null) {\n            string = this.string\n            pointer = \" \".repeat(start) + \"^\".repeat(length)\n            message += \"\\n\\n\" + string + \"\\n\" + pointer\n        }\n        return new ParserError(message)\n    },\n    report: function(error) {\n        this.errors.push(error)\n    }\n}\n\nfunction PageRefParser(string, current=0) {\n    Parser.call(this, string, current)\n    this.tokenType = Token.TYPES.PAGE_REF\n}\nPageRefParser.prototype = Object.create(Parser.prototype)\nPageRefParser.prototype.constructor = PageRefParser\nPageRefParser.prototype.parse = function() {\n    if(this.current !== 0) {\n        throw this.error(`Can only call parse from start of string, not: current = ${this.current}`)\n    }\n    let tokenStart = this.current;\n\n    let tokens = [];\n    if(!this.advance(\"[[\")) {\n        throw this.error(\"PageRef must start with [[\", 0, 2)\n    }\n    while (!this.check(\"]]\") && !this.isAtEnd()) {\n        let token;\n        if(token = this.tokenizeThis()) {\n            tokens.push(token)\n        } else {\n            tokens.push(this.tokenizeChar(1, tokens))\n        }\n    }\n    if(!this.advance(\"]]\")) {\n        throw this.error('Missing closing \"]]\" brackets', this.current, 2)\n    }\n    if(!this.isAtEnd()) {\n        throw this.error('Extra characters after PageRef', this.current, this.string.length - this.current)\n    }\n\n    let lexeme = this.string.slice(tokenStart, this.current);\n    return new Token(this.tokenType, lexeme, tokens, tokenStart)\n}\nPageRefParser.prototype.tokenizeThis = function() {\n    let tokenStart = this.current;\n\n    let tokens = [];\n    if(!this.advance(\"[[\")) return null\n    while (!this.check(\"]]\") && !this.isAtEnd()) {\n        let token;\n        if(token = this.tokenizeThis()) {\n            tokens.push(token)\n        } else {\n            tokens.push(this.tokenizeChar(1, tokens))\n        }\n    }\n    if(!this.advance(\"]]\")) return null\n\n    let lexeme = this.string.slice(tokenStart, this.current);\n    return new Token(this.tokenType, lexeme, tokens, tokenStart)\n}\n\nfunction BlockRefParser(string, current=0) {\n    Parser.call(this, string, current)\n    this.tokenType = Token.TYPES.BLOCK_REF;\n}\nBlockRefParser.prototype = Object.create(Parser.prototype)\nBlockRefParser.prototype.constructor = BlockRefParser\nBlockRefParser.prototype.parse = function() {\n    if(this.current !== 0) {\n        throw this.error(`Can only call parse from start of string, not: current = ${this.current}`)\n    }\n    let tokenStart = this.current;\n\n    let tokens = [];\n    if(!this.advance(\"((\")) {\n        throw this.error('Missing opening \"((\" brackets', 0, 2)\n    }\n    while (!this.check(\"))\") && !this.isAtEnd()) {\n        let token;\n        if(token = this.tokenizeThis()) {\n            tokens.push(token)\n        } else {\n            tokens.push(this.tokenizeChar(1, tokens))\n        }\n    }\n    if(!this.advance(\"))\")) {\n        throw this.error('Missing closing \"))\" brackets', this.current, 2)\n    }\n    if(!this.isAtEnd()) {\n        throw this.error('Extra characters after BlockRef', this.current, this.string.length - this.current)\n    }\n\n    let lexeme = this.string.slice(tokenStart, this.current);\n    return new Token(this.tokenType, lexeme, tokens, tokenStart)\n}\nBlockRefParser.prototype.tokenizeThis = function() {\n    let tokenStart = this.current;\n\n    let tokens = [];\n    if(!this.advance(\"((\")) return null\n    while (!this.check(\"))\") && !this.isAtEnd()) {\n        let token;\n        if(token = this.tokenizeThis()) {\n            tokens.push(token)\n        } else {\n            tokens.push(this.tokenizeChar(1, tokens))\n        }\n    }\n    if(!this.advance(\"))\")) return null\n\n    let lexeme = this.string.slice(tokenStart, this.current);\n    return new Token(this.tokenType, lexeme, tokens, tokenStart)\n}\n\n\nfunction matchPageRef(string, options={global: false}) {\n    let parser = new PageRefParser(string)\n    let token = parser.next()\n    while (token) {\n        if (token.type === parser.tokenType) {\n            let match = [ token.lexeme ];\n            match.index = token.index;\n            match.input = string;\n            return match\n        }\n        token = parser.next()\n    }\n    return null;\n}\n\nfunction getPageRefAtIndex(string, index=0) {\n    let parser = new PageRefParser(string, current=index)\n    return parser.consumeToken()\n}\n\nfunction isPageRef(x) {\n    if (typeof(x) !== \"string\") return false\n    let parser = new PageRefParser(x)\n    try {\n        parser.parse()\n    } catch (e) {\n        if (e instanceof ParserError) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction isBlockRef(x) {\n    if (typeof(x) !== \"string\") return false\n    let parser = new BlockRefParser(x)\n    try {\n        parser.parse()\n    } catch (e) {\n        if (e instanceof ParserError) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction isBlockUid(x) {\n    return typeof (x) === \"string\" && (x.match(/^[\\w\\d\\-_]{9}$/) !== null || x.match(/\\d\\d\\-\\d\\d-\\d\\d\\d\\d/) !== null) // TODO: finish\n}\n\n\nmodule.exports = { isBlockRef, isPageRef, isBlockUid, getPageRefAtIndex, matchPageRef, PageRefParser, BlockRefParser, Token, Parser, ParserError}\n\n//# sourceURL=webpack://roamsh/./src/str.js?");

/***/ }),

/***/ "./src/terminal.js":
/*!*************************!*\
  !*** ./src/terminal.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let { RoamResearchShell } = __webpack_require__(/*! ./rrsh */ \"./src/rrsh.js\");\nlet { Block, Page, Roam } = __webpack_require__(/*! ./graph */ \"./src/graph.js\");\nconst configs = __webpack_require__(/*! ./configs */ \"./src/configs.js\");\n\nfunction Prompt(block, callbacks=[]) {\n    this.block = block\n    this.uid = this.block.uid\n    this.current = \"\"\n    this.commandHistory = []\n    this.commandHistoryId = 0\n    this.observer = null;\n    this.interpreter = new RoamResearchShell()\n    this.callbacks = callbacks;\n}\nPrompt.getFocused = function() {\n    let block = Block.getFocused()\n    if (!block) return null\n    return new Prompt(block)\n}\nPrompt.create = function(block, callbacks) {\n    let prompt = new Prompt(block, callbacks)\n    prompt.addUItoBlock()\n    return prompt\n},\nPrompt.prototype = {\n    ...Prompt.prototype,\n    // Main prompt actions & properties\n    execute: async function () {\n        // Get command from block and save\n        let command = this.getString()\n        this.commandHistory.push(command)\n        this.commandHistoryId = 0\n        // Transpile and execute\n        let [func, ...args]  = this.interpreter.transpile(command)\n        let result = await func(...args)\n        return [command, result, func, args]\n    },\n    goToPrev: function() {\n        if (this.commandHistoryId <= -this.commandHistory.length) {\n            this.commandHistoryId = -this.commandHistory.length\n            return\n        }\n        this.commandHistoryId = this.commandHistoryId - 1\n        let previous = this.commandHistory.slice(this.commandHistoryId)[0]\n        this.block.update(previous)\n    },\n    goToNext: function() {\n        let next;\n        if (this.commandHistoryId < -1) {\n            this.commandHistoryId = this.commandHistoryId + 1\n            next = this.commandHistory.slice(this.commandHistoryId)[0]\n        } else if (this.commandHistoryId === -1) {\n            this.commandHistoryId = this.commandHistoryId + 1\n            next = this.current\n        } else {\n            this.commandHistoryId = 0;\n            next = \"\"\n        }\n        this.block.update(next)\n    },\n    getString: function () {\n        if (this.blockIsFocused()) {\n            return this.block.getTextAreaElement().value\n        } else if(this.blockInView()) {\n            return this.block.getElement().innerText\n        } else {\n            return this.block.getString()\n        }\n    },\n    isEmpty: function() {\n        return this.getString() === \"\"\n    },\n    addUItoBlock: function() {\n        if(!this.blockInView()) {\n            return\n        } \n        if(!this.blockHasPromptUI()) {\n            this.addHTMLToBlock()\n            this.connectObserverToBlock()\n            this.updateUIonBlock()\n        }\n    },\n    removeUIFromBlock: function() {\n        if(!this.blockIsActive()) return\n        this.removeHTMLFromBlock()\n        this.disconnectObserverFromBlock()\n    },\n    updateUIonBlock: function() {\n        this.current = this.getString()\n        let prefix = this.getPrefixElement()\n        let input = this.getInputElement() \n        prefix.style.height = input.clientHeight + \"px\" \n    },\n    // Block properties\n    blockExists: function() {\n        return this.block.exists()\n    },\n    blockInView: function() {\n        return this.block.getElement() !== null\n    },\n    blockIsFocused: function() {\n        return this.block.isFocused()\n    },\n    blockHasPromptUI: function() {\n        termElement = this.block.getElement()\n        return termElement.querySelector(\".rm-block-main\").classList.contains(\"roamsh-prompt\")\n    },\n    blockIsActive: function() {\n        return this.blockInView() && this.blockHasPromptUI()\n    },\n    // Block UI\n    addHTMLToBlock: function() {\n        let termElement = this.block.getElement()\n        termElement.querySelector(\".rm-block-main\").classList.add(\"roamsh-prompt\")\n        let prefix = this.createPrefixElement(configs.ROAMSH_PREFIX)\n        termElement\n            .querySelector(\".controls\")\n            .insertAdjacentElement(\"afterEnd\", prefix)\n    },\n    removeHTMLFromBlock: function() {\n        termElement = this.block.getElement()\n        termElement.querySelector(\".rm-block-main\").classList.remove(\"roamsh-prompt\")\n        let prefix = termElement.querySelector(\".prompt-prefix-area\")\n        if (prefix) prefix.remove()\n    },\n    createPrefixElement: function(string) {\n        prefixElement = document.createElement(\"div\")\n        prefixElement.classList.add(\"prompt-prefix-area\")\n        prefixContent = document.createElement(\"div\")\n        prefixContent.classList.add(\"prompt-prefix-str\")\n        prefixStr = document.createElement(\"span\")\n        prefixStr.innerText = string\n        prefixContent.appendChild(prefixStr)\n        prefixElement.appendChild(prefixContent)\n        return prefixElement\n    },\n    getPrefixElement: function() {\n        let el = this.block.getElement()\n        return el ? el.querySelector(\".prompt-prefix-area\") : null\n    },\n    getInputElement: function() {\n        let el = this.block.getElement()\n        return el ? el.querySelector(\".rm-block__input\") : null\n    },\n    // Listeners\n    connectObserverToBlock: function() {\n        const targetNode = this.block.getElement();\n        const config = { childList: true, subtree: true };\n        this.updateUIonBlock = this.updateUIonBlock.bind(this)\n        this.observer = new MutationObserver(this.updateUIonBlock);\n        this.observer.observe(targetNode, config);\n    },\n    disconnectObserverFromBlock: function() {\n        if (!this.observer) return;\n        this.observer.disconnect();\n        this.observer = null;\n    },\n    // Helpers\n    reportError(error) {\n        errorCodeBlock = \"`\".repeat(3) + \"plain text\\n\" + error.toString() + \"`\".repeat(3)\n        this.block.addChild(errorCodeBlock)\n        throw error\n    }\n}\n\nfunction CodeBlock(element) {\n    this.element = element\n}\nCodeBlock.getFocused = function() {\n    let el = document.activeElement.closest(\".cm-content\")\n    if(!el) return null\n    return new CodeBlock(el)\n}\nCodeBlock.prototype.execute = function() {\n    let code = this.getCode()\n    let res = eval(code)\n    if(res){\n        res = formatResult(res)\n        let block = Block.getFocused()\n        block.addChild(res)\n    }\n} \nCodeBlock.prototype.getCode = function() {\n    return this.element.innerText\n}\nCodeBlock.prototype.getBlock = function() {\n    let el = this.element\n    while(el && !(el.classList.contains(\"roam-block\"))) {\n        el = el.parentElement \n    }\n    let id = el.id || \"\"\n    let match = id.match(/block-input-.*\\d\\d-\\d\\d-\\d\\d\\d\\d-(.*)/) || []\n    if(match[1]) {\n        return new Block(match[1])\n    }    \n    return null\n}\nCodeBlock.prototype.reportError = function(error) {\n    let block = this.getBlock()\n    if(block) {\n        errorCodeBlock = \"`\".repeat(3) + \"plain text\\n\" + error.toString() + \"`\".repeat(3)\n        block.addChild(errorCodeBlock)\n    }\n    throw error\n}\n\n\n\nTerminal = {\n    prompts: {},\n    observer: null,\n    callbacks: [],\n    // User affordances\n    executePrompt: async function(prompt) {\n        if(!prompt) prompt = Prompt.getFocused()\n        try {\n            let [command, result, func, args] = await prompt.execute()\n            for(let callback of this.callbacks) {\n                await callback(prompt, command, result, func, args)\n            }\n        } catch (error) {\n            prompt.reportError(error)\n        }\n    },\n    executeCodeBlock: async function(codeBlock) {\n        if(!codeBlock) codeBlock = CodeBlock.getFocused()\n        try {\n            return await codeBlock.execute()\n        } catch (error) {\n            codeBlock.reportError(error)\n        }\n    },\n    hotkeyHandler: function(e) {\n        if (e.ctrlKey && e.metaKey && e.key == \"Enter\") {\n            let codeBlock = CodeBlock.getFocused()\n            if(codeBlock) {\n                this.executeCodeBlock()\n                return\n            }\n            let block = Block.getFocused()\n            if(block) {\n                let prompt = this.getPrompt(block)\n                if(!prompt) {\n                    this.createPrompt(block)\n                } else if(prompt.isEmpty()) {\n                    this.deletePrompt(prompt)\n                } else {\n                    this.executePrompt(prompt)\n                }\n            }\n        } else if (e.ctrlKey && e.metaKey && e.key===\"ArrowUp\") {\n            let prompt = this.getPrompt()\n            if(!prompt) return\n            prompt.goToPrev()\n        } else if (e.ctrlKey && e.metaKey && e.key===\"ArrowDown\") {\n            let prompt = this.getPrompt()\n            if(!prompt) return\n            prompt.goToNext()\n        }\n    },\n    commandPalleteHandler: function() {\n        let block = Block.getFocused()\n        let prompt = this.getPrompt(block)\n        if(!prompt) {\n            this.createPrompt(block)\n        } else {\n            this.deletePrompt(prompt)\n        }\n    },\n    // Prompt CRUD\n    createPrompt: function(block = null) {\n        block = block || Block.getFocused()\n        let prompt = Prompt.create(block, this.callbacks)\n        this.prompts[block.uid] = prompt\n        if(this.count() === 1) {\n            this.startUpdatePromptsOnViewChange()\n        }\n        return prompt\n    },\n    getPrompt: function(block = null) {\n        block = block || Block.getFocused()\n        return this.prompts[block.uid]\n    },\n    updatePrompt: function(prompt) {\n        if (!prompt.blockExists()) {\n            this.deletePrompt(prompt)\n        } else if (prompt.blockInView() && !prompt.blockHasPromptUI()) {\n            prompt.addUItoBlock()\n        }\n    },\n    deletePrompt: function(prompt) {\n        prompt.removeUIFromBlock()\n        delete this.prompts[prompt.block.uid]\n        if(this.count() === 0) {\n            this.stopUpdatePromptsOnViewChange()\n        }\n    },\n    // Maintain prompt UI and state\n    updatePrompts: function() {\n        // Update prompts\n        for(let prompt of Object.values(this.prompts)) {\n            this.updatePrompt(prompt)\n        }\n    },\n    startUpdatePromptsOnViewChange: function() {\n        const targetNode = document.querySelector('.roam-app');\n        const config = { childList: true, subtree: true };\n        this.updatePrompts = this.updatePrompts.bind(this)\n        this.observer = new MutationObserver(this.updatePrompts);\n        this.observer.observe(targetNode, config);\n    },\n    stopUpdatePromptsOnViewChange: function() {\n        if (!this.observer) return;\n        this.observer.disconnect();\n        this.observer = null;\n    },\n    // Set up and tear down  \n    setUp: function() {\n        this.addStyle()\n        this.addCommandToPallete()\n        this.addHotkeyListener()\n        this.resetCallbacks()\n    },\n    tearDown: function() {\n        for (let [uid, prompt] of Object.entries(this.prompts)) {\n            this.deletePrompt(prompt)\n        }\n        this.removeCommandFromPallete()\n        this.removeHotkeyListener()\n        this.callbacks = []\n    },\n    resetCallbacks: function() {\n        this.callbacks = [defaultPromptCallback]\n    },\n    addStyle: function() {\n        let el = document.getElementById(configs.ROAMSH_CSS_ID);\n        if (el) {\n            return el\n        }\n        el = document.createElement(\"style\");\n        el.textContent = configs.ROAMSH_CSS;\n        el.id = configs.ROAMSH_CSS_ID\n        document.getElementsByTagName(\"head\")[0].appendChild(el);\n        return el;\n    },\n    addCommandToPallete: function() {\n        this.commandPalleteHandler = this.commandPalleteHandler.bind(this)\n        window.roamAlphaAPI.ui.commandPalette.addCommand({\n            label: configs.ROAMSH_TERM_LABEL, \n            callback: this.commandPalleteHandler    \n        })\n    },\n    removeCommandFromPallete: function() {\n        window.roamAlphaAPI.ui.commandPalette.removeCommand({\n            label: configs.ROAMSH_TERM_LABEL})\n    },\n    addHotkeyListener: function() {\n        this.hotkeyHandler = this.hotkeyHandler.bind(this)\n        const roamTerminal = document.querySelector(\".roam-app\") \n        roamTerminal.addEventListener(\"keydown\", this.hotkeyHandler) \n    },\n    removeHotkeyListener: function() {\n        const roamTerminal = document.querySelector(\".roam-app\") \n        roamTerminal.removeEventListener(\"keydown\", this.hotkeyHandler)\n    },\n    // Helpers\n    count: function() {\n        return Object.keys(this.prompts).length\n    },\n}\n\nfunction formatResult(result) {\n    formatFunction = (f) => f.toString().split(\"\\n\").slice(0,1) + \"}\"\n    if(!result) return\n    // Put objects and functions inside code blocks\n    if(typeof(result) === 'object') {\n        let replacer = (k, v) => typeof(v) === 'function' ? formatFunction(v) : v\n        let json = JSON.stringify(result, replacer, \"\\t\")\n        return '`'.repeat(3) + 'javascript\\n' + json + '`'.repeat(3)\n    }\n    if(typeof(result) === 'function') {\n        return '`'.repeat(3) + 'javascript\\n' + formatFunction(f) + '`'.repeat(3)\n    }\n    // and everything else as a string \n    return result.toString()\n}\n\nasync function defaultPromptCallback(prompt, command, result, func, args) {\n    // Clear prompt\n    await prompt.block.update(\"\");\n    // Add result below prompt\n    if(!result) return\n    result = formatResult(result)\n    await prompt.block.addChild(result)\n}\n\nmodule.exports = { Terminal, Prompt, formatResult }\n\n//# sourceURL=webpack://roamsh/./src/terminal.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((module) => {

eval("\n\nfunction getParents(uid, sorted=true) {\n    let parents = window.roamAlphaAPI.q(`[\n        :find [(pull ?p [*]) ...]\n        :where\n            [?e :block/uid \"${uid}\"]\n            [?e :block/parents ?p]\n    ]`)\n    if (sorted) parents = sortParents(parents)\n    return parents.map(obj => obj.uid)\n}\n\nfunction sortParents(parents) {\n    let maxiters = parents.length**2\n    let count = 0\n    let sortedParents = []\n    while (parents.length > 0) {\n        if (count > maxiters) {\n            throw \"Hit max iteration while sorting parents\"\n        }\n        [parent, ...parents] = parents\n        if (sortedParents.length === 0) {\n            sortedParents.push(parent)\n            continue;\n        }\n        let [ first, last ] = [ sortedParents[0], sortedParents[sortedParents.length - 1] ]\n        if (last.children.map(obj => obj.id).includes(parent.id)) {\n            // parent is a child of the last sorted node\n            sortedParents.push(parent);\n        } else if (parent.children.map(obj => obj.id).includes(first.id)) {\n            // parent is parent of the first sorted node\n            sortedParents = [parent].concat(sortedParents)\n        } else {\n            parents.push(parent)\n        }\n        count += 1\n    }\n    return sortedParents\n}\n\nfunction getParent(uid) {\n    return this.getParents(uid).slice(-1)[0]\n}\n\nfunction getChildren(uid, sorted=true) {\n    let uids = window.roamAlphaAPI.q(`[\n        :find [ ?uids ... ]\n        :where\n            [?e :block/uid \"${uid}\"]\n            [?e :block/children ?c]\n            [?c :block/uid ?uids]\n    ]`)\n    if(sorted) {\n        uids = uids.sort((x,y) => getOrder(x) - getOrder(y))\n    }\n    return uids\n}\n\nfunction getSiblings(uid) {\n    let parentUid = this.getParent(uid)\n    return this.getChildren(parentUid)\n}\n\nfunction getOrder(uid) {\n    return getProperty(uid, \"order\")\n}\n\nfunction getString(uid) {\n    return getProperty(uid, \"string\")\n}\n\nfunction getFocused(uid) {\n    return roamAlphaAPI.ui.getFocusedBlock()[\"block-uid\"]\n}\n\nfunction isBlock(uid) {\n    let res = getProperty(uid, \"title\", \"node\")\n    return res === null\n}\n\nfunction isPage(uid) {\n    let res = getProperty(uid, \"title\", \"node\")\n    return res !== null\n}\n\nfunction getProperty(uid, name, namespace=\"block\") {\n    return window.roamAlphaAPI.q(`[\n        :find ?v .\n        :where\n            [?e :block/uid \"${uid}\"]\n            [?e :${namespace}/${name} ?v]\n    ]`)\n}\n\nfunction getPropertyList(uid, name, namespace=\"block\") {\n    return window.roamAlphaAPI.q(`[\n        :find [ ?v ... ]\n        :where\n            [?e :block/uid \"${uid}\"]\n            [?e :${namespace}/${name} ?v]\n    ]`)\n}\n\nfunction uidToId(uid) {\n    return window.roamAlphaAPI.q(`[\n        :find ?e .\n        :where\n            [?e :block/uid \"${uid}\"]\n    ]`)\n}\n\nfunction Location(parentUid, order) {\n    this.parentUid = parentUid\n    this.order = order\n}\n\nfunction NotFoundError(message) {\n    instance = new Error(message);\n    instance.name = 'NotFoundError';\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, NotFoundError);\n      }\n    return instance;\n}\nNotFoundError.prototype = Object.create(Error.prototype)\nNotFoundError.prototype.constructor = NotFoundError\n\nmodule.exports = {getParents, getParent, getChildren, getSiblings, getOrder, isBlock, isPage, uidToId, getString, getFocused, sortParents, Location, NotFoundError}\n\n\n\n//# sourceURL=webpack://roamsh/./src/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/roamsh.js");
/******/ 	roamsh = __webpack_exports__;
/******/ 	
/******/ })()
;